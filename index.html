<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="format-detection" content="telephone=no">
  <title>æé€Ÿæ‹–æ‹½æ‹¼å›¾æ¸¸æˆ</title>
  <!-- å¼•å…¥Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- é…ç½®Tailwindè‡ªå®šä¹‰é¢œè‰² -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#4361ee',
            success: '#38b000',
            warning: '#ffbe0b',
            light: '#f8f9fa',
            dark: '#212529',
            gray: '#6c757d'
          },
          boxShadow: {
            'game': '0 4px 12px rgba(0, 0, 0, 0.1)',
            'game-hover': '0 6px 16px rgba(0, 0, 0, 0.15)',
            'piece': '0 3px 8px rgba(0, 0, 0, 0.12)',
            'modal': '0 8px 24px rgba(0, 0, 0, 0.2)'
          }
        }
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .timer-font {
                font-family: 'Consolas', monospace;
            }
            .shake {
                animation: shake 0.1s linear;
            }
            .modal-pop {
                animation: modalPop 0.2s linear;
            }
            /* æ–°å¢ï¼šç¦æ­¢flexå­å…ƒç´ æ”¶ç¼© */
            .flex-shrink-0 {
                flex-shrink: 0;
            }
            @keyframes shake {
                0%, 100% { transform: translate3d(0, 0, 0); }
                25% { transform: translate3d(-2px, 0, 0); }
                75% { transform: translate3d(2px, 0, 0); }
            }
            @keyframes modalPop {
                from { opacity: 0; transform: scale(0.95); }
                to { opacity: 1; transform: scale(1); }
            }
        }
    </style>
</head>

<body class="bg-gradient-to-br from-[#e8f4f8] to-[#f0f8fb] min-h-screen text-dark touch-none">
  <div class="container mx-auto bg-white p-5 overflow-hidden">
    <div class="header flex flex-wrap justify-between items-center mb-6 gap-4">
      <h1 class="text-primary text-[clamp(20px,5vw,28px)] font-semibold relative pb-2">
        æé€Ÿæ‹–æ‹½æ‹¼å›¾æ¸¸æˆ
        <span class="absolute left-0 bottom-0 w-10 h-[3px] bg-primary"></span>
      </h1>
      <div class="game-info flex items-center gap-3 flex-wrap">
        <select id="difficultySelect"
          class="difficulty-select px-3 py-1.5 border border-[#e1e5e9] bg-light text-dark outline-none focus:border-primary focus:shadow-[0_0_0_2px_rgba(67,97,238,0.1)] text-sm">
          <option value="4">4Ã—4 (ç®€å•)</option>
          <option value="5">5Ã—5 (ä¸­ç­‰)</option>
          <option value="6">6Ã—6 (å›°éš¾)</option>
        </select>
        <div id="timer"
          class="timer bg-light px-4 py-2 timer-font font-semibold text-primary text-[clamp(14px,4vw,16px)] min-w-[80px] text-center shadow-[inset_0_1px_3px_rgba(0,0,0,0.05)]">
          00:00.0</div>
        <div class="btn-group flex gap-2">
          <button id="startBtn"
            class="start-btn px-4 py-2 cursor-pointer text-sm font-medium flex items-center justify-center min-h-[40px] min-w-[80px] bg-primary text-white hover:bg-[#3a56d4] hover:shadow-game-hover hover:-translate-y-0.5 transition-all">å¼€å§‹æ¸¸æˆ</button>
          <button id="resetBtn"
            class="reset-btn px-4 py-2 cursor-pointer text-sm font-medium flex items-center justify-center min-h-[40px] min-w-[80px] bg-light text-dark hover:bg-[#e9ecef] hover:shadow-game-hover hover:-translate-y-0.5 transition-all hidden">é‡æ–°å¼€å§‹</button>
          <button id="hintBtn"
            class="hint-btn px-4 py-2 cursor-pointer text-sm font-medium flex items-center justify-center min-h-[40px] min-w-[80px] bg-light text-dark hover:bg-[#e9ecef] hover:shadow-game-hover hover:-translate-y-0.5 transition-all disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none"
            disabled>æç¤º</button>
        </div>
      </div>
    </div>

    <div id="puzzleBoard"
      class="puzzle-board border-2 border-[#e1e5e9] mx-auto mb-6 grid bg-light overflow-hidden shadow-[inset_0_2px_4px_rgba(0,0,0,0.03)]">
    </div>

    <!-- çˆ¶å®¹å™¨å¢åŠ align-items-centerï¼Œç¡®ä¿æ‹¼å›¾å—å‚ç›´å±…ä¸­ -->
    <div id="piecesContainer"
      class="pieces-container flex flex-nowrap items-center gap-2.5 justify-start mt-5 p-4 bg-light overflow-x-auto">
    </div>
  </div>

  <div id="hintOverlay"
    class="hint-overlay fixed top-0 left-0 w-full h-full bg-black/60 hidden justify-center items-center z-50">
    <div class="hint-content bg-white p-6 max-w-[90%] text-center">
      <h3 class="text-lg font-medium mb-2">æ‹¼å›¾å‚è€ƒ</h3>
      <p class="text-gray mb-4">è¿™æ˜¯å®Œæ•´çš„å›¾ç‰‡å‚è€ƒï¼</p>
      <img
        src="https://gips1.baidu.com/it/u=2178022794,1740207030&fm=3042&app=3042&f=JPEG&wm=1,baiduai3,0,0,13,9&wmo=5,5&w=1024&h=1024"
        alt="æ‹¼å›¾å‚è€ƒå›¾" id="hintImg" class="hint-img max-w-full my-4 shadow-game">
      <button id="hintCloseBtn" class="hint-close mt-4 px-4 py-2 bg-primary text-white">çŸ¥é“äº†</button>
    </div>
  </div>

  <div id="completionModal"
    class="completion-modal fixed top-0 left-0 w-full h-full bg-black/70 hidden justify-center items-center z-40 backdrop-blur-sm">
    <div class="modal-content bg-white p-8 text-center shadow-modal max-w-[90%] w-[350px] modal-pop">
      <h2 class="text-success text-[clamp(20px,5vw,24px)] font-medium mb-3">ğŸ‰ æ­å–œå®Œæˆï¼</h2>
      <p class="text-gray mb-5">ä½ æˆåŠŸå®Œæˆäº†æ‹¼å›¾æŒ‘æˆ˜</p>
      <div
        class="time text-[clamp(18px,5vw,22px)] font-semibold text-primary my-[15px] py-3 px-4 bg-light inline-block min-w-[120px]">
        ç”¨æ—¶: <span id="completionTime">00:00.0</span></div>
      <button id="playAgainBtn" class="start-btn px-4 py-2 bg-primary text-white">å†ç©ä¸€æ¬¡</button>
    </div>
  </div>

  <script>
    // æ¸¸æˆæ ¸å¿ƒé…ç½®
    const game = {
      gridSize: 4,
      pieceCount: 16,
      isPlaying: false,
      startTime: null,
      timerInterval: null,
      correctPieces: 0,
      totalBoardSize: 0,
      boardPieceSize: 0,
      pieceSize: 0
    };

    // DOMå…ƒç´ ç¼“å­˜
    const elements = {
      puzzleBoard: document.getElementById('puzzleBoard'),
      piecesContainer: document.getElementById('piecesContainer'),
      startBtn: document.getElementById('startBtn'),
      resetBtn: document.getElementById('resetBtn'),
      hintBtn: document.getElementById('hintBtn'),
      hintOverlay: document.getElementById('hintOverlay'),
      hintCloseBtn: document.getElementById('hintCloseBtn'),
      hintImg: document.getElementById('hintImg'),
      timer: document.getElementById('timer'),
      completionModal: document.getElementById('completionModal'),
      completionTime: document.getElementById('completionTime'),
      playAgainBtn: document.getElementById('playAgainBtn'),
      difficultySelect: document.getElementById('difficultySelect')
    };

    // å…¨å±€çŠ¶æ€ç®¡ç†
    let puzzlePieces = [];
    let slotPositions = [];
    let dragState = {
      piece: null,
      pieceId: null,
      pieceWidth: 0,
      pieceHeight: 0,
      isDragging: false,
      originalParent: null,
      // æ–°å¢ï¼šè®°å½•åŸå§‹ä½ç½®çš„å‰ä¸€ä¸ªå…„å¼Ÿå…ƒç´ ï¼ˆå…³é”®ï¼‰
      originalPrevSibling: null
    };

    // åˆå§‹åŒ–æ¸¸æˆ
    function initGame() {
      // éš¾åº¦åˆ‡æ¢ç›‘å¬
      elements.difficultySelect.addEventListener('change', function () {
        if (!game.isPlaying) {
          game.gridSize = parseInt(this.value);
          game.pieceCount = game.gridSize * game.gridSize;
          calculateDynamicSizes();
          createPuzzleSlots();
        }
      });

      calculateDynamicSizes();
      createPuzzleSlots();
      setupEventListeners();
      window.addEventListener('resize', calculateDynamicSizes);
      elements.hintImg.style.maxWidth = `${Math.min(window.innerWidth * 0.8, 500)}px`;
    }

    // è®¡ç®—åŠ¨æ€å°ºå¯¸
    function calculateDynamicSizes() {
      game.totalBoardSize = Math.min(window.innerWidth * 0.8, 500);
      game.boardPieceSize = game.totalBoardSize / game.gridSize;
      game.pieceSize = game.boardPieceSize * 0.9;

      elements.puzzleBoard.style.width = `${game.totalBoardSize}px`;
      elements.puzzleBoard.style.height = `${game.totalBoardSize}px`;
      elements.puzzleBoard.style.gridTemplateColumns = `repeat(${game.gridSize}, 1fr)`;
      elements.puzzleBoard.style.gridTemplateRows = `repeat(${game.gridSize}, 1fr)`;
      elements.hintImg.style.maxWidth = `${game.totalBoardSize}px`;
    }

    // åˆ›å»ºæ‹¼å›¾æ§½ä½å¹¶è®°å½•åæ ‡
    function createPuzzleSlots() {
      elements.puzzleBoard.innerHTML = '';
      slotPositions = [];

      for (let i = 0; i < game.pieceCount; i++) {
        const slot = document.createElement('div');
        // ç§»é™¤ border æ ·å¼ï¼Œåˆ é™¤åˆ†å‰²çº¿
        slot.className = 'puzzle-slot bg-white relative w-full h-full';
        slot.dataset.index = i;

        // ç»‘å®šæ§½ä½é€šç”¨äº‹ä»¶
        slot.addEventListener('dragover', handleSlotDragOver);
        slot.addEventListener('dragleave', handleSlotDragLeave);
        slot.addEventListener('drop', handleSlotDrop);
        slot.addEventListener('touchstart', (e) => e.preventDefault());
        slot.addEventListener('touchmove', (e) => e.preventDefault());
        slot.addEventListener('touchend', (e) => e.preventDefault());

        elements.puzzleBoard.appendChild(slot);
      }

      // è®°å½•æ¯ä¸ªæ§½ä½çš„ç²¾å‡†åæ ‡
      setTimeout(() => {
        document.querySelectorAll('.puzzle-slot').forEach((slot, index) => {
          const rect = slot.getBoundingClientRect();
          slotPositions[index] = {
            left: rect.left,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom,
            centerX: (rect.left + rect.right) / 2,
            centerY: (rect.top + rect.bottom) / 2,
            element: slot,
            index: index
          };
        });
      }, 0);
    }

    // åˆ›å»ºæ‹¼å›¾å—
    function createPuzzlePieces() {
      calculateDynamicSizes();
      elements.piecesContainer.innerHTML = '';
      puzzlePieces = [];

      // ç”Ÿæˆæ‹¼å›¾å—æ•°æ®
      for (let i = 0; i < game.pieceCount; i++) {
        const row = Math.floor(i / game.gridSize);
        const col = i % game.gridSize;

        const pieceTotalSize = game.pieceSize * game.gridSize;
        const boardTotalSize = game.boardPieceSize * game.gridSize;
        const bgX = -col * game.pieceSize;
        const bgY = -row * game.pieceSize;
        const boardBgX = -col * game.boardPieceSize;
        const boardBgY = -row * game.boardPieceSize;

        puzzlePieces.push({
          id: i,
          correctPosition: i,
          row,
          col,
          bgX,
          bgY,
          boardBgX,
          boardBgY,
          pieceTotalSize,
          boardTotalSize
        });
      }

      // æ‰“ä¹±æ‹¼å›¾å—
      shuffleArray(puzzlePieces);

      // åˆ›å»ºæ‹¼å›¾å—DOMå¹¶ç»‘å®šäº‹ä»¶
      puzzlePieces.forEach(piece => {
        const pieceElement = document.createElement('div');
        // ç»™æ‹¼å›¾å—æ·»åŠ flex-shrink-0ï¼Œç¦æ­¢æ”¶ç¼©ï¼Œä¿ç•™è‡ªèº«å®½åº¦
        pieceElement.className = 'puzzle-piece cursor-grab shadow-piece bg-[url("https://gips1.baidu.com/it/u=2178022794,1740207030&fm=3042&app=3042&f=JPEG&wm=1,baiduai3,0,0,13,9&wmo=5,5&w=1024&h=1024")] bg-no-repeat overflow-hidden touch-none transform-gpu flex-shrink-0';
        pieceElement.dataset.id = piece.id;
        pieceElement.dataset.correctPos = piece.correctPosition;

        pieceElement.style.width = `${game.pieceSize}px`;
        pieceElement.style.height = `${game.pieceSize}px`;
        pieceElement.style.backgroundSize = `${piece.pieceTotalSize}px ${piece.pieceTotalSize}px`;
        pieceElement.style.backgroundPosition = `${piece.bgX}px ${piece.bgY}px`;
        pieceElement.draggable = true;

        // ç»‘å®šPCç«¯æ‹–æ‹½äº‹ä»¶
        pieceElement.addEventListener('dragstart', handlePieceDragStart);

        // ç»‘å®šç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶
        pieceElement.addEventListener('touchstart', handlePieceTouchStart, { passive: false });
        pieceElement.addEventListener('touchmove', handlePieceTouchMove, { passive: false });
        pieceElement.addEventListener('touchend', handlePieceTouchEnd);
        pieceElement.addEventListener('touchcancel', handlePieceTouchEnd);

        elements.piecesContainer.appendChild(pieceElement);
      });

      elements.hintBtn.disabled = false;
      startGame();
    }

    // å¼€å§‹æ¸¸æˆ
    function startGame() {
      game.isPlaying = true;
      game.startTime = Date.now();
      game.correctPieces = 0;

      if (game.timerInterval) clearInterval(game.timerInterval);
      game.timerInterval = setInterval(updateTimer, 100);

      elements.startBtn.classList.add('hidden');
      elements.startBtn.classList.remove('inline-flex');
      elements.resetBtn.classList.remove('hidden');
      elements.resetBtn.classList.add('inline-flex');
      elements.difficultySelect.disabled = true;
    }

    // æ›´æ–°è®¡æ—¶å™¨
    function updateTimer() {
      const elapsedTime = Math.floor((Date.now() - game.startTime) / 1000);
      const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
      const seconds = (elapsedTime % 60).toString().padStart(2, '0');
      const ms = Math.floor((Date.now() - game.startTime) % 1000 / 100);
      elements.timer.textContent = `${minutes}:${seconds}.${ms}`;
    }

    // åœæ­¢è®¡æ—¶å™¨
    function stopTimer() {
      if (game.timerInterval) {
        clearInterval(game.timerInterval);
        game.timerInterval = null;
      }
    }

    // ---------------- æ ¸å¿ƒï¼šç»Ÿä¸€çš„æ‹–æ‹½é€»è¾‘ ----------------
    /**
     * åˆå§‹åŒ–æ‹–æ‹½çŠ¶æ€ï¼ˆPC/ç§»åŠ¨ç«¯é€šç”¨ï¼‰
     */
    function initDragState(pieceElement, x, y) {
      if (!game.isPlaying) return;

      dragState = {
        piece: pieceElement,
        pieceId: pieceElement.dataset.id,
        pieceWidth: pieceElement.offsetWidth,
        pieceHeight: pieceElement.offsetHeight,
        isDragging: true,
        originalParent: pieceElement.parentElement,
        // å…³é”®ï¼šè®°å½•æ‹–æ‹½å‰çš„å‰ä¸€ä¸ªå…„å¼Ÿå…ƒç´ ï¼ˆç”¨äºç²¾å‡†æ”¾å›ï¼‰
        originalPrevSibling: pieceElement.previousSibling
      };

      // è®¾ç½®æ‹–æ‹½æ ·å¼
      pieceElement.style.opacity = '0.9';
      pieceElement.style.zIndex = '1000';

      // ç§»åŠ¨ç«¯fixedå®šä½
      if (isMobile()) {
        pieceElement.style.position = 'fixed';
        pieceElement.style.left = `${x - dragState.pieceWidth / 2}px`;
        pieceElement.style.top = `${y - dragState.pieceHeight / 2}px`;
        pieceElement.style.width = `${dragState.pieceWidth}px`;
        pieceElement.style.height = `${dragState.pieceHeight}px`;
        pieceElement.style.margin = '0';
      }
    }

    /**
     * æ›´æ–°æ‹–æ‹½ä½ç½®ï¼ˆPC/ç§»åŠ¨ç«¯é€šç”¨ï¼‰
     */
    function updateDragPosition(x, y) {
      if (!dragState.isDragging || !dragState.piece) return;

      // æ›´æ–°æ‹¼å›¾å—ä½ç½®
      if (isMobile()) {
        dragState.piece.style.left = `${x - dragState.pieceWidth / 2}px`;
        dragState.piece.style.top = `${y - dragState.pieceHeight / 2}px`;
      }

      // æ¸…é™¤æ‰€æœ‰æ§½ä½é«˜äº®
      document.querySelectorAll('.puzzle-slot').forEach(s => s.classList.remove('bg-[rgba(67,97,238,0.08)]', 'border-[rgba(67,97,238,0.2)]'));

      // æŸ¥æ‰¾ç›®æ ‡æ§½ä½
      const targetSlot = findTargetSlot(x, y);
      if (targetSlot) {
        targetSlot.element.classList.add('bg-[rgba(67,97,238,0.08)]');
      }
    }

    /**
     * ç»“æŸæ‹–æ‹½ï¼ˆPC/ç§»åŠ¨ç«¯é€šç”¨ï¼‰
     */
    function finishDrag(x, y) {
      if (!dragState.isDragging || !dragState.piece) return;

      // é‡ç½®æ‹–æ‹½æ ·å¼
      resetDragStyle();

      // æŸ¥æ‰¾ç›®æ ‡æ§½ä½
      const targetSlot = findTargetSlot(x, y);

      // æ— ç›®æ ‡æ§½ä½æ—¶æ”¾å›åŸå§‹å®¹å™¨
      if (!targetSlot) {
        returnToOriginalContainer();
        dragState = resetDragState();
        return;
      }

      // è·å–æ‹¼å›¾å—æ•°æ®
      const piece = puzzlePieces.find(p => p.id == dragState.pieceId);
      if (!piece) {
        returnToOriginalContainer();
        dragState = resetDragState();
        return;
      }

      // å·²åœ¨ç›®æ ‡æ§½ä½ä¸­åˆ™ç›´æ¥è¿”å›
      if (dragState.piece.parentElement === targetSlot.element) {
        dragState = resetDragState();
        return;
      }

      // æ ¸å¿ƒåˆ¤å®šé€»è¾‘
      if (piece.correctPosition === targetSlot.index) {
        placePieceCorrectly(piece, dragState.piece, targetSlot.element);
      } else {
        // é”™è¯¯æ”¾ç½®æ—¶ï¼šç²¾å‡†æ”¾å›åŸä½ï¼ˆè€Œéåˆ—è¡¨æœ€åï¼‰
        returnToOriginalContainer();
        dragState.piece.classList.add('shake');
        setTimeout(() => dragState.piece.classList.remove('shake'), 100);
      }

      dragState = resetDragState();
    }

    /**
     * å°†æ‹¼å›¾å—æ”¾å›åŸå§‹ä½ç½®ï¼ˆæ ¸å¿ƒä¿®æ”¹å‡½æ•°ï¼‰
     */
    function returnToOriginalContainer() {
      if (dragState.piece && dragState.originalParent) {
        try {
          // å…³é”®ä¿®æ”¹ï¼šä½¿ç”¨insertBeforeæ’å›åŸä½ç½®ï¼Œè€ŒéappendChild
          if (dragState.originalPrevSibling) {
            // å¦‚æœæœ‰å‰ä¸€ä¸ªå…„å¼Ÿå…ƒç´ ï¼Œæ’åœ¨å®ƒåé¢
            dragState.originalParent.insertBefore(dragState.piece, dragState.originalPrevSibling.nextSibling);
          } else {
            // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œæ’åœ¨æœ€å‰é¢
            dragState.originalParent.insertBefore(dragState.piece, dragState.originalParent.firstChild);
          }
          // é‡ç½®æ ·å¼
          dragState.piece.style.width = `${game.pieceSize}px`;
          dragState.piece.style.height = `${game.pieceSize}px`;
          dragState.piece.style.position = '';
          dragState.piece.style.left = '';
          dragState.piece.style.top = '';
          dragState.piece.style.margin = '';
        } catch (e) {
          // å¼‚å¸¸å…œåº•ï¼šä»æ’å›åŸå®¹å™¨çš„åŸä½ç½®ï¼ˆè€Œéæœ€åï¼‰
          elements.piecesContainer.insertBefore(dragState.piece, dragState.originalPrevSibling ? dragState.originalPrevSibling.nextSibling : elements.piecesContainer.firstChild);
        }
      }
    }

    /**
     * æŸ¥æ‰¾ç›®æ ‡æ§½ä½
     */
    function findTargetSlot(x, y) {
      let targetSlot = null;
      let minDistance = Infinity;

      slotPositions.forEach(slot => {
        const distance = Math.sqrt(
          Math.pow(x - slot.centerX, 2) +
          Math.pow(y - slot.centerY, 2)
        );

        if (distance < 50 && distance < minDistance) {
          minDistance = distance;
          targetSlot = slot;
        }
      });

      return targetSlot;
    }

    /**
     * é‡ç½®æ‹–æ‹½æ ·å¼
     */
    function resetDragStyle() {
      if (dragState.piece) {
        dragState.piece.style.opacity = '1';
        dragState.piece.style.zIndex = '1';
        dragState.piece.style.position = '';
        dragState.piece.style.left = '';
        dragState.piece.style.top = '';
        dragState.piece.style.width = '';
        dragState.piece.style.height = '';
        dragState.piece.style.margin = '';
      }
    }

    /**
     * é‡ç½®æ‹–æ‹½çŠ¶æ€
     */
    function resetDragState() {
      return {
        piece: null,
        pieceId: null,
        pieceWidth: 0,
        pieceHeight: 0,
        isDragging: false,
        originalParent: null,
        originalPrevSibling: null
      };
    }

    /**
     * æ­£ç¡®æ”¾ç½®æ‹¼å›¾å—
     */
    function placePieceCorrectly(piece, pieceElement, slot) {
      // é‡ç½®æ ·å¼
      resetDragStyle();

      // ç§»é™¤æ‰€æœ‰äº‹ä»¶
      pieceElement.removeEventListener('dragstart', handlePieceDragStart);
      pieceElement.removeEventListener('touchstart', handlePieceTouchStart);
      pieceElement.removeEventListener('touchmove', handlePieceTouchMove);
      pieceElement.removeEventListener('touchend', handlePieceTouchEnd);
      pieceElement.draggable = false;

      // è®¾ç½®æ­£ç¡®æ ·å¼
      pieceElement.classList.add('correct', 'cursor-default', 'transform-none', 'shadow-none', 'border-none');
      pieceElement.style.width = '100%';
      pieceElement.style.height = '100%';
      pieceElement.style.backgroundSize = `${piece.boardTotalSize}px ${piece.boardTotalSize}px`;
      pieceElement.style.backgroundPosition = `${piece.boardBgX}px ${piece.boardBgY}px`;

      // æ”¾ç½®åˆ°æ§½ä½
      slot.innerHTML = '';
      slot.appendChild(pieceElement);
      slot.classList.add('correct', 'relative');
      slot.innerHTML += '<span class="absolute top-1 right-1 text-xs text-success font-bold">âœ“</span>';

      // ç§»é™¤æ§½ä½äº‹ä»¶
      slot.removeEventListener('dragover', handleSlotDragOver);
      slot.removeEventListener('dragleave', handleSlotDragLeave);
      slot.removeEventListener('drop', handleSlotDrop);

      game.correctPieces++;

      // æ¸¸æˆå®Œæˆåˆ¤å®š
      if (game.correctPieces === game.pieceCount) {
        gameComplete();
      }
    }

    // ---------------- äº‹ä»¶å…¥å£ ----------------
    // PCç«¯æ‹¼å›¾å—æ‹–æ‹½å¼€å§‹
    function handlePieceDragStart(e) {
      initDragState(e.target, e.clientX, e.clientY);
      e.dataTransfer.setData('text/plain', dragState.pieceId);
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setDragImage(e.target, e.target.offsetWidth / 2, e.target.offsetHeight / 2);
    }

    // PCç«¯æ§½ä½æ‹–æ‹½ä¸­
    function handleSlotDragOver(e) {
      if (!game.isPlaying) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      e.currentTarget.classList.add('bg-[rgba(67,97,238,0.08)]');
    }

    // PCç«¯æ§½ä½æ‹–æ‹½ç¦»å¼€
    function handleSlotDragLeave(e) {
      e.currentTarget.classList.remove('bg-[rgba(67,97,238,0.08)]');
    }

    // PCç«¯æ§½ä½æ”¾ç½®
    function handleSlotDrop(e) {
      if (!game.isPlaying) return;
      e.preventDefault();
      e.currentTarget.classList.remove('bg-[rgba(67,97,238,0.08)]');
      finishDrag(e.clientX, e.clientY);
    }

    // ç§»åŠ¨ç«¯è§¦æ‘¸å¼€å§‹
    function handlePieceTouchStart(e) {
      const touch = e.touches[0];
      e.preventDefault();
      initDragState(e.currentTarget, touch.clientX, touch.clientY);
    }

    // ç§»åŠ¨ç«¯è§¦æ‘¸ç§»åŠ¨
    function handlePieceTouchMove(e) {
      const touch = e.touches[0];
      e.preventDefault();
      updateDragPosition(touch.clientX, touch.clientY);
    }

    // ç§»åŠ¨ç«¯è§¦æ‘¸ç»“æŸ
    function handlePieceTouchEnd(e) {
      const touch = e.changedTouches ? e.changedTouches[0] : null;
      if (!touch) {
        resetDragStyle();
        returnToOriginalContainer();
        dragState = resetDragState();
        return;
      }
      finishDrag(touch.clientX, touch.clientY);
    }

    // ---------------- è¾…åŠ©å‡½æ•° ----------------
    // åˆ¤æ–­æ˜¯å¦ä¸ºç§»åŠ¨ç«¯
    function isMobile() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    // æ‰“ä¹±æ•°ç»„
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // æ˜¾ç¤º/å…³é—­æç¤º
    function showHint() {
      if (!game.isPlaying) return;
      elements.hintOverlay.classList.remove('hidden');
      elements.hintOverlay.classList.add('flex');
    }

    function closeHint() {
      elements.hintOverlay.classList.add('hidden');
      elements.hintOverlay.classList.remove('flex');
    }

    // æ¸¸æˆå®Œæˆ
    function gameComplete() {
      game.isPlaying = false;
      stopTimer();

      elements.completionTime.textContent = elements.timer.textContent;
      elements.completionModal.classList.remove('hidden');
      elements.completionModal.classList.add('flex');
      elements.difficultySelect.disabled = false;
    }

    // é‡ç½®æ¸¸æˆ
    function resetGame() {
      stopTimer();
      game.isPlaying = false;
      elements.timer.textContent = '00:00.0';

      elements.puzzleBoard.innerHTML = '';
      elements.piecesContainer.innerHTML = '';

      calculateDynamicSizes();
      createPuzzleSlots();

      elements.startBtn.classList.remove('hidden');
      elements.startBtn.classList.add('inline-flex');
      elements.resetBtn.classList.add('hidden');
      elements.resetBtn.classList.remove('inline-flex');
      elements.completionModal.classList.add('hidden');
      elements.completionModal.classList.remove('flex');
      elements.difficultySelect.disabled = false;
    }

    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    function setupEventListeners() {
      // æ¸¸æˆæ§åˆ¶
      elements.startBtn.addEventListener('click', createPuzzlePieces);
      elements.resetBtn.addEventListener('click', resetGame);
      elements.playAgainBtn.addEventListener('click', () => {
        resetGame();
        setTimeout(createPuzzlePieces, 50);
      });

      // æç¤ºåŠŸèƒ½
      elements.hintBtn.addEventListener('click', showHint);
      elements.hintCloseBtn.addEventListener('click', closeHint);
      elements.hintOverlay.addEventListener('click', function (e) {
        if (e.target === elements.hintOverlay) closeHint();
      });

      // é˜»æ­¢é¡µé¢æ»šåŠ¨
      document.addEventListener('touchmove', function (e) {
        if (dragState.isDragging) e.preventDefault();
      }, { passive: false });
    }

    // åˆå§‹åŒ–æ¸¸æˆ
    initGame();
  </script>
</body>

</html>